/* daemon.c generated by valac 0.20.1.19-a6516, the Vala compiler
 * generated from daemon.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <string.h>
#include <atspi/atspi.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <gdk/gdkx.h>
#include <gtk/gtk.h>
#include <locale.h>
#include <glib/gi18n-lib.h>
#include <stdio.h>
#include <glib-unix.h>
#include <signal.h>


#define CARIBOU_TYPE__KEYBOARD (caribou__keyboard_get_type ())
#define CARIBOU__KEYBOARD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CARIBOU_TYPE__KEYBOARD, Caribou_Keyboard))
#define CARIBOU_IS__KEYBOARD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CARIBOU_TYPE__KEYBOARD))
#define CARIBOU__KEYBOARD_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), CARIBOU_TYPE__KEYBOARD, Caribou_KeyboardIface))

typedef struct _Caribou_Keyboard Caribou_Keyboard;
typedef struct _Caribou_KeyboardIface Caribou_KeyboardIface;

#define CARIBOU_TYPE__KEYBOARD_PROXY (caribou__keyboard_proxy_get_type ())
typedef GDBusProxy Caribou_KeyboardProxy;
typedef GDBusProxyClass Caribou_KeyboardProxyClass;

#define CARIBOU_TYPE_DAEMON (caribou_daemon_get_type ())
#define CARIBOU_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CARIBOU_TYPE_DAEMON, CaribouDaemon))
#define CARIBOU_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CARIBOU_TYPE_DAEMON, CaribouDaemonClass))
#define CARIBOU_IS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CARIBOU_TYPE_DAEMON))
#define CARIBOU_IS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CARIBOU_TYPE_DAEMON))
#define CARIBOU_DAEMON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CARIBOU_TYPE_DAEMON, CaribouDaemonClass))

typedef struct _CaribouDaemon CaribouDaemon;
typedef struct _CaribouDaemonClass CaribouDaemonClass;
typedef struct _CaribouDaemonPrivate CaribouDaemonPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define __vala_AtspiRect_free0(var) ((var == NULL) ? NULL : (var = (_vala_AtspiRect_free (var), NULL)))
#define __vala_AtspiEvent_free0(var) ((var == NULL) ? NULL : (var = (_vala_AtspiEvent_free (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

struct _Caribou_KeyboardIface {
	GTypeInterface parent_iface;
	void (*set_cursor_location) (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error);
	void (*set_entry_location) (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error);
	void (*show) (Caribou_Keyboard* self, guint32 timestamp, GError** error);
	void (*hide) (Caribou_Keyboard* self, guint32 timestamp, GError** error);
};

struct _CaribouDaemon {
	GObject parent_instance;
	CaribouDaemonPrivate * priv;
};

struct _CaribouDaemonClass {
	GObjectClass parent_class;
};

struct _CaribouDaemonPrivate {
	Caribou_Keyboard* keyboard;
	AtspiAccessible* current_acc;
	GdkDisplay* display;
};

struct _Block1Data {
	int _ref_count_;
	CaribouDaemon* daemon;
};


static gpointer caribou_daemon_parent_class = NULL;

GType caribou__keyboard_proxy_get_type (void) G_GNUC_CONST;
guint caribou__keyboard_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType caribou__keyboard_get_type (void) G_GNUC_CONST;
void caribou__keyboard_set_cursor_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error);
void caribou__keyboard_set_entry_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error);
void caribou__keyboard_show (Caribou_Keyboard* self, guint32 timestamp, GError** error);
void caribou__keyboard_hide (Caribou_Keyboard* self, guint32 timestamp, GError** error);
static void caribou__keyboard_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void caribou__keyboard_proxy_set_cursor_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error);
static void caribou__keyboard_proxy_set_entry_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error);
static void caribou__keyboard_proxy_show (Caribou_Keyboard* self, guint32 timestamp, GError** error);
static void caribou__keyboard_proxy_hide (Caribou_Keyboard* self, guint32 timestamp, GError** error);
static void caribou__keyboard_proxy_caribou__keyboard_interface_init (Caribou_KeyboardIface* iface);
static void _dbus_caribou__keyboard_set_cursor_location (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_caribou__keyboard_set_entry_location (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_caribou__keyboard_show (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_caribou__keyboard_hide (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void caribou__keyboard_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* caribou__keyboard_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean caribou__keyboard_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _caribou__keyboard_unregister_object (gpointer user_data);
GType caribou_daemon_get_type (void) G_GNUC_CONST;
#define CARIBOU_DAEMON_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CARIBOU_TYPE_DAEMON, CaribouDaemonPrivate))
enum  {
	CARIBOU_DAEMON_DUMMY_PROPERTY
};
CaribouDaemon* caribou_daemon_new (void);
CaribouDaemon* caribou_daemon_construct (GType object_type);
static void caribou_daemon_on_get_proxy_ready (CaribouDaemon* self, GObject* obj, GAsyncResult* res);
static void caribou_daemon_register_event_listeners (CaribouDaemon* self, GError** error);
static guint32 caribou_daemon_get_timestamp (CaribouDaemon* self);
static void caribou_daemon_set_entry_location (CaribouDaemon* self, AtspiAccessible* acc, GError** error);
static void _vala_AtspiRect_free (AtspiRect* self);
static AtspiRect* _vala_AtspiRect_copy (AtspiRect* self);
static void caribou_daemon_on_focus (CaribouDaemon* self, AtspiEvent* event, GError** error);
static void _vala_AtspiEvent_free (AtspiEvent* self);
static void caribou_daemon_on_focus_ignore_error (CaribouDaemon* self, AtspiEvent* event);
static AtspiEvent* _vala_AtspiEvent_copy (AtspiEvent* self);
static void caribou_daemon_on_text_caret_moved (CaribouDaemon* self, AtspiEvent* event, GError** error);
static void caribou_daemon_on_text_caret_moved_ignore_error (CaribouDaemon* self, AtspiEvent* event);
static void _caribou_daemon_on_focus_ignore_error_atspi_event_listener_cb (AtspiEvent* event, gpointer self);
static void _caribou_daemon_on_text_caret_moved_ignore_error_atspi_event_listener_cb (AtspiEvent* event, gpointer self);
static void caribou_daemon_deregister_event_listeners (CaribouDaemon* self, GError** error);
void caribou_daemon_run (CaribouDaemon* self);
static void _caribou_daemon_on_get_proxy_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
void caribou_daemon_quit (CaribouDaemon* self);
static void caribou_daemon_finalize (GObject* obj);
gint _vala_main (gchar** args, int args_length1);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda2_ (Block1Data* _data1_);
static gboolean ___lambda2__gsource_func (gpointer self);

static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_cursor_location_x = {-1, "x", "i"};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_cursor_location_y = {-1, "y", "i"};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_cursor_location_w = {-1, "w", "i"};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_cursor_location_h = {-1, "h", "i"};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_set_cursor_location_in[] = {&_caribou__keyboard_dbus_arg_info_set_cursor_location_x, &_caribou__keyboard_dbus_arg_info_set_cursor_location_y, &_caribou__keyboard_dbus_arg_info_set_cursor_location_w, &_caribou__keyboard_dbus_arg_info_set_cursor_location_h, NULL};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_set_cursor_location_out[] = {NULL};
static const GDBusMethodInfo _caribou__keyboard_dbus_method_info_set_cursor_location = {-1, "SetCursorLocation", (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_set_cursor_location_in), (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_set_cursor_location_out)};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_entry_location_x = {-1, "x", "i"};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_entry_location_y = {-1, "y", "i"};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_entry_location_w = {-1, "w", "i"};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_set_entry_location_h = {-1, "h", "i"};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_set_entry_location_in[] = {&_caribou__keyboard_dbus_arg_info_set_entry_location_x, &_caribou__keyboard_dbus_arg_info_set_entry_location_y, &_caribou__keyboard_dbus_arg_info_set_entry_location_w, &_caribou__keyboard_dbus_arg_info_set_entry_location_h, NULL};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_set_entry_location_out[] = {NULL};
static const GDBusMethodInfo _caribou__keyboard_dbus_method_info_set_entry_location = {-1, "SetEntryLocation", (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_set_entry_location_in), (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_set_entry_location_out)};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_show_timestamp = {-1, "timestamp", "u"};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_show_in[] = {&_caribou__keyboard_dbus_arg_info_show_timestamp, NULL};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_show_out[] = {NULL};
static const GDBusMethodInfo _caribou__keyboard_dbus_method_info_show = {-1, "Show", (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_show_in), (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_show_out)};
static const GDBusArgInfo _caribou__keyboard_dbus_arg_info_hide_timestamp = {-1, "timestamp", "u"};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_hide_in[] = {&_caribou__keyboard_dbus_arg_info_hide_timestamp, NULL};
static const GDBusArgInfo * const _caribou__keyboard_dbus_arg_info_hide_out[] = {NULL};
static const GDBusMethodInfo _caribou__keyboard_dbus_method_info_hide = {-1, "Hide", (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_hide_in), (GDBusArgInfo **) (&_caribou__keyboard_dbus_arg_info_hide_out)};
static const GDBusMethodInfo * const _caribou__keyboard_dbus_method_info[] = {&_caribou__keyboard_dbus_method_info_set_cursor_location, &_caribou__keyboard_dbus_method_info_set_entry_location, &_caribou__keyboard_dbus_method_info_show, &_caribou__keyboard_dbus_method_info_hide, NULL};
static const GDBusSignalInfo * const _caribou__keyboard_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _caribou__keyboard_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _caribou__keyboard_dbus_interface_info = {-1, "org.gnome.Caribou.Keyboard", (GDBusMethodInfo **) (&_caribou__keyboard_dbus_method_info), (GDBusSignalInfo **) (&_caribou__keyboard_dbus_signal_info), (GDBusPropertyInfo **) (&_caribou__keyboard_dbus_property_info)};
static const GDBusInterfaceVTable _caribou__keyboard_dbus_interface_vtable = {caribou__keyboard_dbus_interface_method_call, caribou__keyboard_dbus_interface_get_property, caribou__keyboard_dbus_interface_set_property};
const GOptionEntry options[1] = {{NULL}};

void caribou__keyboard_set_cursor_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error) {
	g_return_if_fail (self != NULL);
	CARIBOU__KEYBOARD_GET_INTERFACE (self)->set_cursor_location (self, x, y, w, h, error);
}


void caribou__keyboard_set_entry_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error) {
	g_return_if_fail (self != NULL);
	CARIBOU__KEYBOARD_GET_INTERFACE (self)->set_entry_location (self, x, y, w, h, error);
}


void caribou__keyboard_show (Caribou_Keyboard* self, guint32 timestamp, GError** error) {
	g_return_if_fail (self != NULL);
	CARIBOU__KEYBOARD_GET_INTERFACE (self)->show (self, timestamp, error);
}


void caribou__keyboard_hide (Caribou_Keyboard* self, guint32 timestamp, GError** error) {
	g_return_if_fail (self != NULL);
	CARIBOU__KEYBOARD_GET_INTERFACE (self)->hide (self, timestamp, error);
}


static void caribou__keyboard_base_init (Caribou_KeyboardIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType caribou__keyboard_get_type (void) {
	static volatile gsize caribou__keyboard_type_id__volatile = 0;
	if (g_once_init_enter (&caribou__keyboard_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Caribou_KeyboardIface), (GBaseInitFunc) caribou__keyboard_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType caribou__keyboard_type_id;
		caribou__keyboard_type_id = g_type_register_static (G_TYPE_INTERFACE, "Caribou_Keyboard", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (caribou__keyboard_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (caribou__keyboard_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) caribou__keyboard_proxy_get_type);
		g_type_set_qdata (caribou__keyboard_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.gnome.Caribou.Keyboard");
		g_type_set_qdata (caribou__keyboard_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) caribou__keyboard_register_object);
		g_once_init_leave (&caribou__keyboard_type_id__volatile, caribou__keyboard_type_id);
	}
	return caribou__keyboard_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (Caribou_KeyboardProxy, caribou__keyboard_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (CARIBOU_TYPE__KEYBOARD, caribou__keyboard_proxy_caribou__keyboard_interface_init) )
static void caribou__keyboard_proxy_class_init (Caribou_KeyboardProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = caribou__keyboard_proxy_g_signal;
}


static void caribou__keyboard_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
}


static void caribou__keyboard_proxy_init (Caribou_KeyboardProxy* self) {
}


static void caribou__keyboard_proxy_set_cursor_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.Caribou.Keyboard", "SetCursorLocation");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (x));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (y));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (w));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (h));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void caribou__keyboard_proxy_set_entry_location (Caribou_Keyboard* self, gint x, gint y, gint w, gint h, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.Caribou.Keyboard", "SetEntryLocation");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (x));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (y));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (w));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (h));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void caribou__keyboard_proxy_show (Caribou_Keyboard* self, guint32 timestamp, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.Caribou.Keyboard", "Show");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (timestamp));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void caribou__keyboard_proxy_hide (Caribou_Keyboard* self, guint32 timestamp, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.Caribou.Keyboard", "Hide");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (timestamp));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void caribou__keyboard_proxy_caribou__keyboard_interface_init (Caribou_KeyboardIface* iface) {
	iface->set_cursor_location = caribou__keyboard_proxy_set_cursor_location;
	iface->set_entry_location = caribou__keyboard_proxy_set_entry_location;
	iface->show = caribou__keyboard_proxy_show;
	iface->hide = caribou__keyboard_proxy_hide;
}


static void _dbus_caribou__keyboard_set_cursor_location (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gint x = 0;
	GVariant* _tmp0_;
	gint y = 0;
	GVariant* _tmp1_;
	gint w = 0;
	GVariant* _tmp2_;
	gint h = 0;
	GVariant* _tmp3_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	x = g_variant_get_int32 (_tmp0_);
	g_variant_unref (_tmp0_);
	_tmp1_ = g_variant_iter_next_value (&_arguments_iter);
	y = g_variant_get_int32 (_tmp1_);
	g_variant_unref (_tmp1_);
	_tmp2_ = g_variant_iter_next_value (&_arguments_iter);
	w = g_variant_get_int32 (_tmp2_);
	g_variant_unref (_tmp2_);
	_tmp3_ = g_variant_iter_next_value (&_arguments_iter);
	h = g_variant_get_int32 (_tmp3_);
	g_variant_unref (_tmp3_);
	caribou__keyboard_set_cursor_location (self, x, y, w, h, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_caribou__keyboard_set_entry_location (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gint x = 0;
	GVariant* _tmp4_;
	gint y = 0;
	GVariant* _tmp5_;
	gint w = 0;
	GVariant* _tmp6_;
	gint h = 0;
	GVariant* _tmp7_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp4_ = g_variant_iter_next_value (&_arguments_iter);
	x = g_variant_get_int32 (_tmp4_);
	g_variant_unref (_tmp4_);
	_tmp5_ = g_variant_iter_next_value (&_arguments_iter);
	y = g_variant_get_int32 (_tmp5_);
	g_variant_unref (_tmp5_);
	_tmp6_ = g_variant_iter_next_value (&_arguments_iter);
	w = g_variant_get_int32 (_tmp6_);
	g_variant_unref (_tmp6_);
	_tmp7_ = g_variant_iter_next_value (&_arguments_iter);
	h = g_variant_get_int32 (_tmp7_);
	g_variant_unref (_tmp7_);
	caribou__keyboard_set_entry_location (self, x, y, w, h, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_caribou__keyboard_show (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	guint32 timestamp = 0U;
	GVariant* _tmp8_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp8_ = g_variant_iter_next_value (&_arguments_iter);
	timestamp = g_variant_get_uint32 (_tmp8_);
	g_variant_unref (_tmp8_);
	caribou__keyboard_show (self, timestamp, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_caribou__keyboard_hide (Caribou_Keyboard* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	guint32 timestamp = 0U;
	GVariant* _tmp9_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp9_ = g_variant_iter_next_value (&_arguments_iter);
	timestamp = g_variant_get_uint32 (_tmp9_);
	g_variant_unref (_tmp9_);
	caribou__keyboard_hide (self, timestamp, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void caribou__keyboard_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "SetCursorLocation") == 0) {
		_dbus_caribou__keyboard_set_cursor_location (object, parameters, invocation);
	} else if (strcmp (method_name, "SetEntryLocation") == 0) {
		_dbus_caribou__keyboard_set_entry_location (object, parameters, invocation);
	} else if (strcmp (method_name, "Show") == 0) {
		_dbus_caribou__keyboard_show (object, parameters, invocation);
	} else if (strcmp (method_name, "Hide") == 0) {
		_dbus_caribou__keyboard_hide (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* caribou__keyboard_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean caribou__keyboard_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint caribou__keyboard_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_caribou__keyboard_dbus_interface_info), &_caribou__keyboard_dbus_interface_vtable, data, _caribou__keyboard_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _caribou__keyboard_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


CaribouDaemon* caribou_daemon_construct (GType object_type) {
	CaribouDaemon * self = NULL;
	GdkDisplay* _tmp0_ = NULL;
	self = (CaribouDaemon*) g_object_new (object_type, NULL);
	_tmp0_ = gdk_display_get_default ();
	self->priv->display = _tmp0_;
	return self;
}


CaribouDaemon* caribou_daemon_new (void) {
	return caribou_daemon_construct (CARIBOU_TYPE_DAEMON);
}


static void caribou_daemon_on_get_proxy_ready (CaribouDaemon* self, GObject* obj, GAsyncResult* res) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (res != NULL);
	{
		Caribou_Keyboard* _tmp0_ = NULL;
		GAsyncResult* _tmp1_;
		Caribou_Keyboard* _tmp2_ = NULL;
		Caribou_Keyboard* _tmp3_ = NULL;
		_tmp1_ = res;
		_tmp2_ = g_async_result_get_source_object (_tmp1_);
		_tmp3_ = g_async_initable_new_finish (_tmp2_, _tmp1_, &_inner_error_);
		g_object_unref (_tmp2_);
		_tmp0_ = (Caribou_Keyboard*) _tmp3_;
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_g_object_unref0 (self->priv->keyboard);
		self->priv->keyboard = _tmp0_;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e->message;
		_tmp5_ = g_strdup_printf ("%s\n", _tmp4_);
		_tmp6_ = _tmp5_;
		g_error ("daemon.vala:27: %s", _tmp6_);
		_g_free0 (_tmp6_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		caribou_daemon_register_event_listeners (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		GError* _tmp7_;
		const gchar* _tmp8_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		g_warning ("daemon.vala:33: can't register event listeners: %s", _tmp8_);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static guint32 caribou_daemon_get_timestamp (CaribouDaemon* self) {
	guint32 result = 0U;
	GdkDisplay* _tmp0_;
	guint32 _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->display;
	_tmp1_ = gdk_x11_display_get_user_time (_tmp0_);
	result = _tmp1_;
	return result;
}


static void _vala_AtspiRect_free (AtspiRect* self) {
	g_boxed_free (atspi_rect_get_type (), self);
}


static AtspiRect* _vala_AtspiRect_copy (AtspiRect* self) {
	return g_boxed_copy (atspi_rect_get_type (), self);
}


static gpointer __vala_AtspiRect_copy0 (gpointer self) {
	return self ? _vala_AtspiRect_copy (self) : NULL;
}


static void caribou_daemon_set_entry_location (CaribouDaemon* self, AtspiAccessible* acc, GError** error) {
	AtspiText* text = NULL;
	AtspiAccessible* _tmp0_;
	AtspiText* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	AtspiText* _tmp3_;
	gint _tmp4_ = 0;
	AtspiRect* rect = NULL;
	AtspiText* _tmp5_;
	AtspiRect* _tmp6_ = NULL;
	AtspiComponent* component = NULL;
	AtspiAccessible* _tmp7_;
	AtspiComponent* _tmp8_ = NULL;
	AtspiRect* entry_rect = NULL;
	AtspiComponent* _tmp9_;
	AtspiRect* _tmp10_ = NULL;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	AtspiRect* _tmp14_;
	gint _tmp15_;
	gboolean _tmp18_;
	gboolean _tmp21_;
	gboolean _tmp24_;
	Caribou_Keyboard* _tmp27_;
	AtspiRect* _tmp28_;
	gint _tmp29_;
	AtspiRect* _tmp30_;
	gint _tmp31_;
	AtspiRect* _tmp32_;
	gint _tmp33_;
	AtspiRect* _tmp34_;
	gint _tmp35_;
	Caribou_Keyboard* _tmp36_;
	AtspiRect* _tmp37_;
	gint _tmp38_;
	AtspiRect* _tmp39_;
	gint _tmp40_;
	AtspiRect* _tmp41_;
	gint _tmp42_;
	AtspiRect* _tmp43_;
	gint _tmp44_;
	Caribou_Keyboard* _tmp45_;
	guint32 _tmp46_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (acc != NULL);
	_tmp0_ = acc;
	_tmp1_ = atspi_accessible_get_text (_tmp0_);
	text = _tmp1_;
	_tmp3_ = text;
	_tmp4_ = atspi_text_get_caret_offset (_tmp3_, &_inner_error_);
	_tmp2_ = _tmp4_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (text);
		return;
	}
	_tmp5_ = text;
	_tmp6_ = atspi_text_get_character_extents (_tmp5_, _tmp2_, ATSPI_COORD_TYPE_SCREEN, &_inner_error_);
	rect = _tmp6_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (text);
		return;
	}
	_tmp7_ = acc;
	_tmp8_ = atspi_accessible_get_component (_tmp7_);
	component = _tmp8_;
	_tmp9_ = component;
	_tmp10_ = atspi_component_get_extents (_tmp9_, ATSPI_COORD_TYPE_SCREEN, &_inner_error_);
	entry_rect = _tmp10_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (component);
		__vala_AtspiRect_free0 (rect);
		_g_object_unref0 (text);
		return;
	}
	_tmp14_ = rect;
	_tmp15_ = _tmp14_->x;
	if (_tmp15_ == 0) {
		AtspiRect* _tmp16_;
		gint _tmp17_;
		_tmp16_ = rect;
		_tmp17_ = _tmp16_->y;
		_tmp13_ = _tmp17_ == 0;
	} else {
		_tmp13_ = FALSE;
	}
	_tmp18_ = _tmp13_;
	if (_tmp18_) {
		AtspiRect* _tmp19_;
		gint _tmp20_;
		_tmp19_ = rect;
		_tmp20_ = _tmp19_->width;
		_tmp12_ = _tmp20_ == 0;
	} else {
		_tmp12_ = FALSE;
	}
	_tmp21_ = _tmp12_;
	if (_tmp21_) {
		AtspiRect* _tmp22_;
		gint _tmp23_;
		_tmp22_ = rect;
		_tmp23_ = _tmp22_->height;
		_tmp11_ = _tmp23_ == 0;
	} else {
		_tmp11_ = FALSE;
	}
	_tmp24_ = _tmp11_;
	if (_tmp24_) {
		AtspiRect* _tmp25_;
		AtspiRect* _tmp26_;
		_tmp25_ = entry_rect;
		_tmp26_ = __vala_AtspiRect_copy0 (_tmp25_);
		__vala_AtspiRect_free0 (rect);
		rect = _tmp26_;
	}
	_tmp27_ = self->priv->keyboard;
	_tmp28_ = rect;
	_tmp29_ = _tmp28_->x;
	_tmp30_ = rect;
	_tmp31_ = _tmp30_->y;
	_tmp32_ = rect;
	_tmp33_ = _tmp32_->width;
	_tmp34_ = rect;
	_tmp35_ = _tmp34_->height;
	caribou__keyboard_set_cursor_location (_tmp27_, _tmp29_, _tmp31_, _tmp33_, _tmp35_, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		__vala_AtspiRect_free0 (entry_rect);
		_g_object_unref0 (component);
		__vala_AtspiRect_free0 (rect);
		_g_object_unref0 (text);
		return;
	}
	_tmp36_ = self->priv->keyboard;
	_tmp37_ = entry_rect;
	_tmp38_ = _tmp37_->x;
	_tmp39_ = entry_rect;
	_tmp40_ = _tmp39_->y;
	_tmp41_ = entry_rect;
	_tmp42_ = _tmp41_->width;
	_tmp43_ = entry_rect;
	_tmp44_ = _tmp43_->height;
	caribou__keyboard_set_entry_location (_tmp36_, _tmp38_, _tmp40_, _tmp42_, _tmp44_, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		__vala_AtspiRect_free0 (entry_rect);
		_g_object_unref0 (component);
		__vala_AtspiRect_free0 (rect);
		_g_object_unref0 (text);
		return;
	}
	_tmp45_ = self->priv->keyboard;
	_tmp46_ = caribou_daemon_get_timestamp (self);
	caribou__keyboard_show (_tmp45_, _tmp46_, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		__vala_AtspiRect_free0 (entry_rect);
		_g_object_unref0 (component);
		__vala_AtspiRect_free0 (rect);
		_g_object_unref0 (text);
		return;
	}
	__vala_AtspiRect_free0 (entry_rect);
	_g_object_unref0 (component);
	__vala_AtspiRect_free0 (rect);
	_g_object_unref0 (text);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _vala_AtspiEvent_free (AtspiEvent* self) {
	g_boxed_free (atspi_event_get_type (), self);
}


static void caribou_daemon_on_focus (CaribouDaemon* self, AtspiEvent* event, GError** error) {
	AtspiAccessible* acc = NULL;
	AtspiEvent* _tmp0_;
	AtspiAccessible* _tmp1_;
	AtspiAccessible* _tmp2_;
	AtspiRole source_role = 0;
	AtspiAccessible* _tmp3_;
	AtspiRole _tmp4_ = 0;
	gboolean _tmp5_ = FALSE;
	AtspiAccessible* _tmp6_;
	AtspiStateSet* _tmp7_ = NULL;
	AtspiStateSet* _tmp8_;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_;
	gboolean _tmp12_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->source;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	acc = _tmp2_;
	_tmp3_ = acc;
	_tmp4_ = atspi_accessible_get_role (_tmp3_, &_inner_error_);
	source_role = _tmp4_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (acc);
		__vala_AtspiEvent_free0 (event);
		return;
	}
	_tmp6_ = acc;
	_tmp7_ = atspi_accessible_get_state_set (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = atspi_state_set_contains (_tmp8_, ATSPI_STATE_EDITABLE);
	_tmp10_ = _tmp9_;
	_g_object_unref0 (_tmp8_);
	if (_tmp10_) {
		_tmp5_ = TRUE;
	} else {
		AtspiRole _tmp11_;
		_tmp11_ = source_role;
		_tmp5_ = _tmp11_ == ATSPI_ROLE_TERMINAL;
	}
	_tmp12_ = _tmp5_;
	if (_tmp12_) {
		AtspiRole _tmp13_;
		_tmp13_ = source_role;
		switch (_tmp13_) {
			case ATSPI_ROLE_TEXT:
			case ATSPI_ROLE_PARAGRAPH:
			case ATSPI_ROLE_PASSWORD_TEXT:
			case ATSPI_ROLE_TERMINAL:
			case ATSPI_ROLE_ENTRY:
			{
				gboolean _tmp14_ = FALSE;
				AtspiEvent* _tmp15_;
				const gchar* _tmp16_;
				gboolean _tmp17_ = FALSE;
				gboolean _tmp20_;
				_tmp15_ = event;
				_tmp16_ = _tmp15_->type;
				_tmp17_ = g_str_has_prefix (_tmp16_, "focus");
				if (_tmp17_) {
					_tmp14_ = TRUE;
				} else {
					AtspiEvent* _tmp18_;
					gint _tmp19_;
					_tmp18_ = event;
					_tmp19_ = _tmp18_->detail1;
					_tmp14_ = _tmp19_ == 1;
				}
				_tmp20_ = _tmp14_;
				if (_tmp20_) {
					AtspiAccessible* _tmp21_;
					AtspiEvent* _tmp22_;
					AtspiAccessible* _tmp23_;
					AtspiAccessible* _tmp24_;
					AtspiAccessible* _tmp25_ = NULL;
					AtspiEvent* _tmp26_;
					AtspiAccessible* _tmp27_;
					AtspiAccessible* _tmp28_ = NULL;
					AtspiAccessible* _tmp29_;
					const gchar* _tmp30_;
					_tmp21_ = acc;
					caribou_daemon_set_entry_location (self, _tmp21_, &_inner_error_);
					if (_inner_error_ != NULL) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (acc);
						__vala_AtspiEvent_free0 (event);
						return;
					}
					_tmp22_ = event;
					_tmp23_ = _tmp22_->source;
					_tmp24_ = _g_object_ref0 (_tmp23_);
					_g_object_unref0 (self->priv->current_acc);
					self->priv->current_acc = _tmp24_;
					_tmp26_ = event;
					_tmp27_ = _tmp26_->source;
					_tmp28_ = atspi_accessible_get_application (_tmp27_, &_inner_error_);
					_tmp25_ = _tmp28_;
					if (_inner_error_ != NULL) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (acc);
						__vala_AtspiEvent_free0 (event);
						return;
					}
					_tmp29_ = _tmp25_;
					_tmp30_ = _tmp29_->name;
					g_debug ("daemon.vala:75: enter text widget in %s", _tmp30_);
					_g_object_unref0 (_tmp29_);
				} else {
					gboolean _tmp31_ = FALSE;
					AtspiEvent* _tmp32_;
					gint _tmp33_;
					gboolean _tmp36_;
					_tmp32_ = event;
					_tmp33_ = _tmp32_->detail1;
					if (_tmp33_ == 0) {
						AtspiAccessible* _tmp34_;
						AtspiAccessible* _tmp35_;
						_tmp34_ = acc;
						_tmp35_ = self->priv->current_acc;
						_tmp31_ = _tmp34_ == _tmp35_;
					} else {
						_tmp31_ = FALSE;
					}
					_tmp36_ = _tmp31_;
					if (_tmp36_) {
						Caribou_Keyboard* _tmp37_;
						guint32 _tmp38_ = 0U;
						AtspiAccessible* _tmp39_ = NULL;
						AtspiEvent* _tmp40_;
						AtspiAccessible* _tmp41_;
						AtspiAccessible* _tmp42_ = NULL;
						AtspiAccessible* _tmp43_;
						const gchar* _tmp44_;
						_tmp37_ = self->priv->keyboard;
						_tmp38_ = caribou_daemon_get_timestamp (self);
						caribou__keyboard_hide (_tmp37_, _tmp38_, &_inner_error_);
						if (_inner_error_ != NULL) {
							g_propagate_error (error, _inner_error_);
							_g_object_unref0 (acc);
							__vala_AtspiEvent_free0 (event);
							return;
						}
						_g_object_unref0 (self->priv->current_acc);
						self->priv->current_acc = NULL;
						_tmp40_ = event;
						_tmp41_ = _tmp40_->source;
						_tmp42_ = atspi_accessible_get_application (_tmp41_, &_inner_error_);
						_tmp39_ = _tmp42_;
						if (_inner_error_ != NULL) {
							g_propagate_error (error, _inner_error_);
							_g_object_unref0 (acc);
							__vala_AtspiEvent_free0 (event);
							return;
						}
						_tmp43_ = _tmp39_;
						_tmp44_ = _tmp43_->name;
						g_debug ("daemon.vala:80: leave text widget in %s", _tmp44_);
						_g_object_unref0 (_tmp43_);
					} else {
						AtspiEvent* _tmp45_;
						AtspiAccessible* _tmp46_;
						const gchar* _tmp47_;
						_tmp45_ = event;
						_tmp46_ = _tmp45_->source;
						_tmp47_ = _tmp46_->name;
						g_warning ("daemon.vala:83: unhandled editable widget: %s", _tmp47_);
					}
				}
				break;
			}
			default:
			{
				break;
			}
		}
	}
	_g_object_unref0 (acc);
	__vala_AtspiEvent_free0 (event);
}


static AtspiEvent* _vala_AtspiEvent_copy (AtspiEvent* self) {
	return g_boxed_copy (atspi_event_get_type (), self);
}


static gpointer __vala_AtspiEvent_copy0 (gpointer self) {
	return self ? _vala_AtspiEvent_copy (self) : NULL;
}


static void caribou_daemon_on_focus_ignore_error (CaribouDaemon* self, AtspiEvent* event) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	{
		AtspiEvent* _tmp0_;
		AtspiEvent* _tmp1_;
		_tmp0_ = event;
		_tmp1_ = __vala_AtspiEvent_copy0 (_tmp0_);
		caribou_daemon_on_focus (self, _tmp1_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		GError* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_warning ("daemon.vala:97: error in focus handler: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		__vala_AtspiEvent_free0 (event);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	__vala_AtspiEvent_free0 (event);
}


static void caribou_daemon_on_text_caret_moved (CaribouDaemon* self, AtspiEvent* event, GError** error) {
	AtspiAccessible* _tmp0_;
	AtspiEvent* _tmp1_;
	AtspiAccessible* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	_tmp0_ = self->priv->current_acc;
	_tmp1_ = event;
	_tmp2_ = _tmp1_->source;
	if (_tmp0_ == _tmp2_) {
		AtspiText* text = NULL;
		AtspiAccessible* _tmp3_;
		AtspiText* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		AtspiText* _tmp6_;
		gint _tmp7_ = 0;
		AtspiRect* rect = NULL;
		AtspiText* _tmp8_;
		AtspiRect* _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_ = FALSE;
		gboolean _tmp12_ = FALSE;
		AtspiRect* _tmp13_;
		gint _tmp14_;
		gboolean _tmp17_;
		gboolean _tmp20_;
		gboolean _tmp23_;
		Caribou_Keyboard* _tmp29_;
		AtspiRect* _tmp30_;
		gint _tmp31_;
		AtspiRect* _tmp32_;
		gint _tmp33_;
		AtspiRect* _tmp34_;
		gint _tmp35_;
		AtspiRect* _tmp36_;
		gint _tmp37_;
		AtspiAccessible* _tmp38_ = NULL;
		AtspiEvent* _tmp39_;
		AtspiAccessible* _tmp40_;
		AtspiAccessible* _tmp41_ = NULL;
		AtspiAccessible* _tmp42_;
		const gchar* _tmp43_;
		AtspiEvent* _tmp44_;
		gint _tmp45_;
		AtspiEvent* _tmp46_;
		AtspiAccessible* _tmp47_;
		const gchar* _tmp48_;
		_tmp3_ = self->priv->current_acc;
		_tmp4_ = atspi_accessible_get_text (_tmp3_);
		text = _tmp4_;
		_tmp6_ = text;
		_tmp7_ = atspi_text_get_caret_offset (_tmp6_, &_inner_error_);
		_tmp5_ = _tmp7_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (text);
			__vala_AtspiEvent_free0 (event);
			return;
		}
		_tmp8_ = text;
		_tmp9_ = atspi_text_get_character_extents (_tmp8_, _tmp5_, ATSPI_COORD_TYPE_SCREEN, &_inner_error_);
		rect = _tmp9_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (text);
			__vala_AtspiEvent_free0 (event);
			return;
		}
		_tmp13_ = rect;
		_tmp14_ = _tmp13_->x;
		if (_tmp14_ == 0) {
			AtspiRect* _tmp15_;
			gint _tmp16_;
			_tmp15_ = rect;
			_tmp16_ = _tmp15_->y;
			_tmp12_ = _tmp16_ == 0;
		} else {
			_tmp12_ = FALSE;
		}
		_tmp17_ = _tmp12_;
		if (_tmp17_) {
			AtspiRect* _tmp18_;
			gint _tmp19_;
			_tmp18_ = rect;
			_tmp19_ = _tmp18_->width;
			_tmp11_ = _tmp19_ == 0;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp20_ = _tmp11_;
		if (_tmp20_) {
			AtspiRect* _tmp21_;
			gint _tmp22_;
			_tmp21_ = rect;
			_tmp22_ = _tmp21_->height;
			_tmp10_ = _tmp22_ == 0;
		} else {
			_tmp10_ = FALSE;
		}
		_tmp23_ = _tmp10_;
		if (_tmp23_) {
			AtspiComponent* component = NULL;
			AtspiAccessible* _tmp24_;
			AtspiComponent* _tmp25_ = NULL;
			AtspiRect* _tmp26_ = NULL;
			AtspiComponent* _tmp27_;
			AtspiRect* _tmp28_ = NULL;
			_tmp24_ = self->priv->current_acc;
			_tmp25_ = atspi_accessible_get_component (_tmp24_);
			component = _tmp25_;
			_tmp27_ = component;
			_tmp28_ = atspi_component_get_extents (_tmp27_, ATSPI_COORD_TYPE_SCREEN, &_inner_error_);
			_tmp26_ = _tmp28_;
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (component);
				__vala_AtspiRect_free0 (rect);
				_g_object_unref0 (text);
				__vala_AtspiEvent_free0 (event);
				return;
			}
			__vala_AtspiRect_free0 (rect);
			rect = _tmp26_;
			_g_object_unref0 (component);
		}
		_tmp29_ = self->priv->keyboard;
		_tmp30_ = rect;
		_tmp31_ = _tmp30_->x;
		_tmp32_ = rect;
		_tmp33_ = _tmp32_->y;
		_tmp34_ = rect;
		_tmp35_ = _tmp34_->width;
		_tmp36_ = rect;
		_tmp37_ = _tmp36_->height;
		caribou__keyboard_set_cursor_location (_tmp29_, _tmp31_, _tmp33_, _tmp35_, _tmp37_, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			__vala_AtspiRect_free0 (rect);
			_g_object_unref0 (text);
			__vala_AtspiEvent_free0 (event);
			return;
		}
		_tmp39_ = event;
		_tmp40_ = _tmp39_->source;
		_tmp41_ = atspi_accessible_get_application (_tmp40_, &_inner_error_);
		_tmp38_ = _tmp41_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			__vala_AtspiRect_free0 (rect);
			_g_object_unref0 (text);
			__vala_AtspiEvent_free0 (event);
			return;
		}
		_tmp42_ = _tmp38_;
		_tmp43_ = _tmp42_->name;
		_tmp44_ = event;
		_tmp45_ = _tmp44_->detail1;
		_tmp46_ = event;
		_tmp47_ = _tmp46_->source;
		_tmp48_ = _tmp47_->description;
		g_debug ("daemon.vala:114: object:text-caret-moved in %s: %d %s", _tmp43_, _tmp45_, _tmp48_);
		_g_object_unref0 (_tmp42_);
		__vala_AtspiRect_free0 (rect);
		_g_object_unref0 (text);
	}
	__vala_AtspiEvent_free0 (event);
}


static void caribou_daemon_on_text_caret_moved_ignore_error (CaribouDaemon* self, AtspiEvent* event) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	{
		AtspiEvent* _tmp0_;
		AtspiEvent* _tmp1_;
		_tmp0_ = event;
		_tmp1_ = __vala_AtspiEvent_copy0 (_tmp0_);
		caribou_daemon_on_text_caret_moved (self, _tmp1_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		GError* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_warning ("daemon.vala:124: error in text caret movement handler: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		__vala_AtspiEvent_free0 (event);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	__vala_AtspiEvent_free0 (event);
}


static void _caribou_daemon_on_focus_ignore_error_atspi_event_listener_cb (AtspiEvent* event, gpointer self) {
	caribou_daemon_on_focus_ignore_error (self, event);
}


static void _caribou_daemon_on_text_caret_moved_ignore_error_atspi_event_listener_cb (AtspiEvent* event, gpointer self) {
	caribou_daemon_on_text_caret_moved_ignore_error (self, event);
}


static void caribou_daemon_register_event_listeners (CaribouDaemon* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	atspi_event_listener_register_from_callback (_caribou_daemon_on_focus_ignore_error_atspi_event_listener_cb, g_object_ref (self), g_object_unref, "object:state-changed:focused", &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	atspi_event_listener_register_from_callback (_caribou_daemon_on_focus_ignore_error_atspi_event_listener_cb, g_object_ref (self), g_object_unref, "focus:", &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	atspi_event_listener_register_from_callback (_caribou_daemon_on_text_caret_moved_ignore_error_atspi_event_listener_cb, g_object_ref (self), g_object_unref, "object:text-caret-moved", &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
}


static void caribou_daemon_deregister_event_listeners (CaribouDaemon* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	atspi_event_listener_deregister_from_callback (_caribou_daemon_on_focus_ignore_error_atspi_event_listener_cb, self, "object:state-changed:focused", &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	atspi_event_listener_deregister_from_callback (_caribou_daemon_on_focus_ignore_error_atspi_event_listener_cb, self, "focus:", &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	atspi_event_listener_deregister_from_callback (_caribou_daemon_on_text_caret_moved_ignore_error_atspi_event_listener_cb, self, "object:text-caret-moved", &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
}


static void _caribou_daemon_on_get_proxy_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
	caribou_daemon_on_get_proxy_ready (self, source_object, res);
	g_object_unref (self);
}


void caribou_daemon_run (CaribouDaemon* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_async_initable_new_async (CARIBOU_TYPE__KEYBOARD_PROXY, 0, NULL, _caribou_daemon_on_get_proxy_ready_gasync_ready_callback, g_object_ref (self), "g-flags", 0, "g-name", "org.gnome.Caribou.Keyboard", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/gnome/Caribou/Keyboard", "g-interface-name", "org.gnome.Caribou.Keyboard", NULL);
	gtk_main ();
}


void caribou_daemon_quit (CaribouDaemon* self) {
	Caribou_Keyboard* _tmp0_;
	guint _tmp7_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->keyboard;
	if (_tmp0_ != NULL) {
		{
			Caribou_Keyboard* _tmp1_;
			guint32 _tmp2_ = 0U;
			_tmp1_ = self->priv->keyboard;
			_tmp2_ = caribou_daemon_get_timestamp (self);
			caribou__keyboard_hide (_tmp1_, _tmp2_, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_IO_ERROR) {
					goto __catch4_g_io_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally4;
		__catch4_g_io_error:
		{
			GError* e = NULL;
			GError* _tmp3_;
			const gchar* _tmp4_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp3_ = e;
			_tmp4_ = _tmp3_->message;
			g_warning ("daemon.vala:161: can't hide keyboard: %s", _tmp4_);
			_g_error_free0 (e);
		}
		__finally4:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		{
			caribou_daemon_deregister_event_listeners (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch5_g_error;
			}
		}
		goto __finally5;
		__catch5_g_error:
		{
			GError* e = NULL;
			GError* _tmp5_;
			const gchar* _tmp6_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp5_ = e;
			_tmp6_ = _tmp5_->message;
			g_warning ("daemon.vala:167: can't deregister event listeners: %s", _tmp6_);
			_g_error_free0 (e);
		}
		__finally5:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (self->priv->keyboard);
		self->priv->keyboard = NULL;
	}
	_tmp7_ = gtk_main_level ();
	if (_tmp7_ > ((guint) 0)) {
		gtk_main_quit ();
	}
}


static void caribou_daemon_class_init (CaribouDaemonClass * klass) {
	caribou_daemon_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CaribouDaemonPrivate));
	G_OBJECT_CLASS (klass)->finalize = caribou_daemon_finalize;
}


static void caribou_daemon_instance_init (CaribouDaemon * self) {
	self->priv = CARIBOU_DAEMON_GET_PRIVATE (self);
}


static void caribou_daemon_finalize (GObject* obj) {
	CaribouDaemon * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CARIBOU_TYPE_DAEMON, CaribouDaemon);
	_g_object_unref0 (self->priv->keyboard);
	_g_object_unref0 (self->priv->current_acc);
	G_OBJECT_CLASS (caribou_daemon_parent_class)->finalize (obj);
}


GType caribou_daemon_get_type (void) {
	static volatile gsize caribou_daemon_type_id__volatile = 0;
	if (g_once_init_enter (&caribou_daemon_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CaribouDaemonClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) caribou_daemon_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CaribouDaemon), 0, (GInstanceInitFunc) caribou_daemon_instance_init, NULL };
		GType caribou_daemon_type_id;
		caribou_daemon_type_id = g_type_register_static (G_TYPE_OBJECT, "CaribouDaemon", &g_define_type_info, 0);
		g_once_init_leave (&caribou_daemon_type_id__volatile, caribou_daemon_type_id);
	}
	return caribou_daemon_type_id__volatile;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->daemon);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda2_ (Block1Data* _data1_) {
	gboolean result = FALSE;
	CaribouDaemon* _tmp0_;
	_tmp0_ = _data1_->daemon;
	caribou_daemon_quit (_tmp0_);
	result = FALSE;
	return result;
}


static gboolean ___lambda2__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda2_ (self);
	return result;
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	Block1Data* _data1_;
	GOptionContext* option_context = NULL;
	GOptionContext* _tmp0_;
	GOptionContext* _tmp1_;
	gint retval = 0;
	gint _tmp6_ = 0;
	gint _tmp7_;
	CaribouDaemon* _tmp8_;
	CaribouDaemon* _tmp9_;
	GError * _inner_error_ = NULL;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	gtk_init (&args_length1, &args);
	setlocale (LC_ALL, "");
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	_tmp0_ = g_option_context_new ("- daemon listening accessibility events to launch on screen keyboard");
	option_context = _tmp0_;
	_tmp1_ = option_context;
	g_option_context_add_main_entries (_tmp1_, options, "caribou");
	{
		GOptionContext* _tmp2_;
		_tmp2_ = option_context;
		g_option_context_parse (_tmp2_, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch6_g_option_error;
			}
			_g_option_context_free0 (option_context);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	goto __finally6;
	__catch6_g_option_error:
	{
		GError* e = NULL;
		FILE* _tmp3_;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = stderr;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		fprintf (_tmp3_, "%s\n", _tmp5_);
		result = 1;
		_g_error_free0 (e);
		_g_option_context_free0 (option_context);
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	}
	__finally6:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (option_context);
		block1_data_unref (_data1_);
		_data1_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp6_ = atspi_init ();
	retval = _tmp6_;
	_tmp7_ = retval;
	if (_tmp7_ != 0) {
		g_printerr ("can't initialize atspi\n");
		result = 1;
		_g_option_context_free0 (option_context);
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	}
	_tmp8_ = caribou_daemon_new ();
	_data1_->daemon = _tmp8_;
	g_unix_signal_add_full (G_PRIORITY_DEFAULT, SIGINT, ___lambda2__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	_tmp9_ = _data1_->daemon;
	caribou_daemon_run (_tmp9_);
	result = 0;
	_g_option_context_free0 (option_context);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}



